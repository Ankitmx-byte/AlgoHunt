{"ast":null,"code":"// This file contains sample module content data based on open source educational resources\n// Sources include:\n// - Open Data Structures (opendatastructures.org)\n// - Introduction to Algorithms, 3rd Edition (CLRS)\n// - Algorithms by Jeff Erickson\n// - MDN Web Docs (developer.mozilla.org)\n// - React Documentation (reactjs.org)\n// - Node.js Documentation (nodejs.org)\n// - Python.org and Real Python\n// - JavaScript.info and MDN Web Docs\n\nimport { getJavaScriptModuleContent } from './jsModuleContentData';\nimport { getPythonModuleContent } from './pythonModuleContentData';\nexport const getModuleContent = moduleId => {\n  // Check if this is a JavaScript module\n  if (moduleId.startsWith('js-mod-')) {\n    return getJavaScriptModuleContent(moduleId);\n  }\n\n  // Check if this is a Python module\n  if (moduleId.startsWith('py-mod-')) {\n    return getPythonModuleContent(moduleId);\n  }\n\n  // Otherwise, use the original module content\n  const moduleContent = {\n    // Arrays and Strings module content\n    \"m1\": {\n      id: \"m1\",\n      title: \"Arrays and Strings\",\n      content: [{\n        type: \"text\",\n        title: \"Introduction to Arrays\",\n        body: `\n            <p>Arrays are one of the most fundamental data structures in computer science. An array is a collection of elements, each identified by an index or a key.</p>\n\n            <p>The simplest type of array is a <strong>linear array</strong> or <strong>one-dimensional array</strong>, which is a collection of data elements with the same data type, arranged using a single index.</p>\n\n            <p>Key characteristics of arrays:</p>\n            <ul>\n              <li><strong>Random Access</strong>: Elements can be accessed directly using their index</li>\n              <li><strong>Fixed Size</strong>: In many languages, arrays have a fixed size that is defined when the array is created</li>\n              <li><strong>Homogeneous Elements</strong>: All elements in the array have the same data type</li>\n              <li><strong>Contiguous Memory</strong>: Array elements are stored in adjacent memory locations</li>\n            </ul>\n\n            <p>The time complexity of common array operations:</p>\n            <ul>\n              <li>Access: O(1)</li>\n              <li>Search: O(n)</li>\n              <li>Insertion: O(n)</li>\n              <li>Deletion: O(n)</li>\n            </ul>\n\n            <p>Arrays are implemented differently in various programming languages. In low-level languages like C, arrays are fixed-size blocks of contiguous memory. In higher-level languages like JavaScript or Python, arrays are more flexible and can grow or shrink dynamically.</p>\n          `\n      }, {\n        type: \"text\",\n        title: \"Array Memory Layout\",\n        body: `\n            <p>Understanding how arrays are stored in memory is crucial for optimizing performance and understanding the limitations of arrays.</p>\n\n            <p>In most programming languages, arrays are stored in contiguous blocks of memory. This means that all elements of the array are stored next to each other in memory.</p>\n\n            <p>For example, if we have an array of integers where each integer takes 4 bytes of memory, and the array starts at memory address 1000, then:</p>\n            <ul>\n              <li>The first element (index 0) will be at address 1000</li>\n              <li>The second element (index 1) will be at address 1004</li>\n              <li>The third element (index 2) will be at address 1008</li>\n              <li>And so on...</li>\n            </ul>\n\n            <p>This contiguous memory layout is what allows arrays to provide O(1) access time. The memory address of any element can be calculated using the formula:</p>\n\n            <p><code>address = base_address + (index * element_size)</code></p>\n\n            <p>Where <code>base_address</code> is the memory address of the first element, <code>index</code> is the position of the element we want to access, and <code>element_size</code> is the size of each element in bytes.</p>\n\n            <p>This formula works because the elements are stored contiguously in memory, so we can simply calculate the offset from the base address.</p>\n          `\n      }, {\n        type: \"video\",\n        title: \"Array Data Structure Visualization\",\n        description: \"This video provides a visual explanation of how arrays work in memory and demonstrates common array operations.\",\n        source: \"CS Dojo\",\n        notes: \"Pay special attention to the visualization of array insertion and deletion operations, as they require shifting elements which leads to O(n) time complexity.\"\n      }, {\n        type: \"text\",\n        title: \"Dynamic Arrays\",\n        body: `\n            <p>While traditional arrays have a fixed size, many modern programming languages provide dynamic arrays that can grow or shrink as needed. Examples include ArrayList in Java, vector in C++, and the built-in arrays in JavaScript and Python.</p>\n\n            <p>Dynamic arrays overcome the limitation of fixed-size arrays by automatically resizing when they run out of space. When a dynamic array needs to grow, it typically:</p>\n\n            <ol>\n              <li>Allocates a new, larger array (usually twice the size of the original)</li>\n              <li>Copies all elements from the original array to the new array</li>\n              <li>Deallocates the original array</li>\n            </ol>\n\n            <p>This resizing operation is expensive (O(n) time complexity), but it happens infrequently enough that the amortized cost of adding an element to a dynamic array is still O(1).</p>\n\n            <p>The concept of <strong>amortized analysis</strong> is important here. While a single resize operation is expensive, it happens rarely enough that when we average the cost over many operations, the cost per operation is still constant.</p>\n\n            <p>Dynamic arrays provide a good balance between the flexibility of linked lists and the performance of fixed-size arrays.</p>\n          `\n      }, {\n        type: \"quiz\",\n        title: \"Array Concepts Quiz\",\n        description: \"Test your understanding of array concepts with this quiz.\",\n        questions: [{\n          id: \"q1\",\n          text: \"What is the time complexity of accessing an element in an array by its index?\",\n          options: [{\n            id: \"a\",\n            text: \"O(1)\"\n          }, {\n            id: \"b\",\n            text: \"O(log n)\"\n          }, {\n            id: \"c\",\n            text: \"O(n)\"\n          }, {\n            id: \"d\",\n            text: \"O(n²)\"\n          }],\n          correctAnswer: \"a\"\n        }, {\n          id: \"q2\",\n          text: \"What happens when a dynamic array needs to grow beyond its current capacity?\",\n          options: [{\n            id: \"a\",\n            text: \"It returns an error\"\n          }, {\n            id: \"b\",\n            text: \"It creates a new, larger array and copies the elements\"\n          }, {\n            id: \"c\",\n            text: \"It automatically extends the existing memory block\"\n          }, {\n            id: \"d\",\n            text: \"It converts to a linked list\"\n          }],\n          correctAnswer: \"b\"\n        }, {\n          id: \"q3\",\n          text: \"What is the time complexity of inserting an element at the beginning of an array?\",\n          options: [{\n            id: \"a\",\n            text: \"O(1)\"\n          }, {\n            id: \"b\",\n            text: \"O(log n)\"\n          }, {\n            id: \"c\",\n            text: \"O(n)\"\n          }, {\n            id: \"d\",\n            text: \"O(n²)\"\n          }],\n          correctAnswer: \"c\"\n        }]\n      }, {\n        type: \"exercise\",\n        title: \"Array Manipulation Exercise\",\n        description: \"Implement a function to reverse an array in-place without using any built-in reverse functions.\",\n        instructions: [\"Create a function called 'reverseArray' that takes an array as input\", \"The function should reverse the array in-place (without creating a new array)\", \"Do not use any built-in reverse functions\", \"Return the reversed array\"],\n        starterCode: `function reverseArray(arr) {\n  // Your code here\n\n  return arr;\n}\n\n// Example usage:\n// const arr = [1, 2, 3, 4, 5];\n// console.log(reverseArray(arr)); // Should output: [5, 4, 3, 2, 1]`,\n        solution: `function reverseArray(arr) {\n  let left = 0;\n  let right = arr.length - 1;\n\n  while (left < right) {\n    // Swap elements at left and right indices\n    const temp = arr[left];\n    arr[left] = arr[right];\n    arr[right] = temp;\n\n    // Move indices towards the center\n    left++;\n    right--;\n  }\n\n  return arr;\n}\n\n// Example usage:\n// const arr = [1, 2, 3, 4, 5];\n// console.log(reverseArray(arr)); // Should output: [5, 4, 3, 2, 1]`\n      }]\n    },\n    // Linked Lists module content\n    \"m2\": {\n      id: \"m2\",\n      title: \"Linked Lists\",\n      content: [{\n        type: \"text\",\n        title: \"Introduction to Linked Lists\",\n        body: `\n            <p>A linked list is a linear data structure where elements are not stored in contiguous memory locations. Instead, each element (node) contains a reference (link) to the next node in the sequence.</p>\n\n            <p>Unlike arrays, linked lists do not provide random access to elements. To access a specific element, you must traverse the list from the beginning (head) until you reach the desired element.</p>\n\n            <p>The basic structure of a linked list node typically includes:</p>\n            <ul>\n              <li>Data: The value stored in the node</li>\n              <li>Next: A reference to the next node in the sequence</li>\n            </ul>\n\n            <p>Linked lists offer several advantages over arrays:</p>\n            <ul>\n              <li>Dynamic size: Linked lists can grow or shrink during execution</li>\n              <li>Efficient insertions and deletions: Adding or removing elements doesn't require shifting other elements</li>\n              <li>Flexible memory allocation: Nodes can be stored anywhere in memory</li>\n            </ul>\n\n            <p>However, linked lists also have some disadvantages:</p>\n            <ul>\n              <li>No random access: To access an element, you must traverse from the beginning</li>\n              <li>Extra memory: Each node requires additional memory for the reference</li>\n              <li>Cache performance: Nodes may be scattered in memory, reducing cache efficiency</li>\n            </ul>\n          `\n      }, {\n        type: \"text\",\n        title: \"Types of Linked Lists\",\n        body: `\n            <p>There are several types of linked lists, each with its own characteristics and use cases:</p>\n\n            <h4>Singly Linked List</h4>\n            <p>In a singly linked list, each node contains a reference to the next node in the sequence. Traversal can only be done in one direction, from the head to the tail.</p>\n\n            <pre>\nHead → [Data|Next] → [Data|Next] → [Data|Next] → null\n            </pre>\n\n            <h4>Doubly Linked List</h4>\n            <p>In a doubly linked list, each node contains references to both the next and previous nodes. This allows traversal in both directions but requires more memory per node.</p>\n\n            <pre>\nnull ← [Prev|Data|Next] ↔ [Prev|Data|Next] ↔ [Prev|Data|Next] → null\n       ↑\n      Head\n            </pre>\n\n            <h4>Circular Linked List</h4>\n            <p>In a circular linked list, the last node points back to the first node, creating a circle. This can be implemented with either singly or doubly linked lists.</p>\n\n            <pre>\n       ┌────────────────────────┐\n       ↓                        |\nHead → [Data|Next] → [Data|Next] → [Data|Next]\n            </pre>\n\n            <p>Each type of linked list has its own advantages and is suitable for different scenarios.</p>\n          `\n      }, {\n        type: \"video\",\n        title: \"Linked List Implementation\",\n        description: \"This video demonstrates how to implement a singly linked list from scratch, including common operations like insertion, deletion, and traversal.\",\n        source: \"freeCodeCamp.org\",\n        notes: \"Focus on understanding the pointer manipulation required for operations like insertion and deletion, as these are the key advantages of linked lists.\"\n      }, {\n        type: \"quiz\",\n        title: \"Linked List Concepts Quiz\",\n        description: \"Test your understanding of linked list concepts with this quiz.\",\n        questions: [{\n          id: \"q1\",\n          text: \"What is the time complexity of accessing the nth element in a singly linked list?\",\n          options: [{\n            id: \"a\",\n            text: \"O(1)\"\n          }, {\n            id: \"b\",\n            text: \"O(log n)\"\n          }, {\n            id: \"c\",\n            text: \"O(n)\"\n          }, {\n            id: \"d\",\n            text: \"O(n²)\"\n          }],\n          correctAnswer: \"c\"\n        }, {\n          id: \"q2\",\n          text: \"Which type of linked list allows traversal in both directions?\",\n          options: [{\n            id: \"a\",\n            text: \"Singly linked list\"\n          }, {\n            id: \"b\",\n            text: \"Doubly linked list\"\n          }, {\n            id: \"c\",\n            text: \"Circular linked list\"\n          }, {\n            id: \"d\",\n            text: \"Skip list\"\n          }],\n          correctAnswer: \"b\"\n        }, {\n          id: \"q3\",\n          text: \"What is the time complexity of inserting a node at the beginning of a singly linked list?\",\n          options: [{\n            id: \"a\",\n            text: \"O(1)\"\n          }, {\n            id: \"b\",\n            text: \"O(log n)\"\n          }, {\n            id: \"c\",\n            text: \"O(n)\"\n          }, {\n            id: \"d\",\n            text: \"O(n²)\"\n          }],\n          correctAnswer: \"a\"\n        }]\n      }, {\n        type: \"exercise\",\n        title: \"Linked List Implementation Exercise\",\n        description: \"Implement a singly linked list with basic operations.\",\n        instructions: [\"Create a Node class with properties for the data and next pointer\", \"Create a LinkedList class with a head property\", \"Implement methods for append, prepend, delete, and print\", \"Test your implementation with the provided example\"],\n        starterCode: `class Node {\n  // Your code here\n}\n\nclass LinkedList {\n  constructor() {\n    this.head = null;\n  }\n\n  // Add a node to the end of the list\n  append(data) {\n    // Your code here\n  }\n\n  // Add a node to the beginning of the list\n  prepend(data) {\n    // Your code here\n  }\n\n  // Delete a node with the given data\n  delete(data) {\n    // Your code here\n  }\n\n  // Print the linked list\n  print() {\n    // Your code here\n  }\n}\n\n// Example usage:\n// const list = new LinkedList();\n// list.append(1);\n// list.append(2);\n// list.prepend(0);\n// list.print(); // Should output: 0 -> 1 -> 2\n// list.delete(1);\n// list.print(); // Should output: 0 -> 2`,\n        solution: `class Node {\n  constructor(data) {\n    this.data = data;\n    this.next = null;\n  }\n}\n\nclass LinkedList {\n  constructor() {\n    this.head = null;\n  }\n\n  // Add a node to the end of the list\n  append(data) {\n    const newNode = new Node(data);\n\n    if (!this.head) {\n      this.head = newNode;\n      return;\n    }\n\n    let current = this.head;\n    while (current.next) {\n      current = current.next;\n    }\n\n    current.next = newNode;\n  }\n\n  // Add a node to the beginning of the list\n  prepend(data) {\n    const newNode = new Node(data);\n    newNode.next = this.head;\n    this.head = newNode;\n  }\n\n  // Delete a node with the given data\n  delete(data) {\n    if (!this.head) return;\n\n    if (this.head.data === data) {\n      this.head = this.head.next;\n      return;\n    }\n\n    let current = this.head;\n    while (current.next && current.next.data !== data) {\n      current = current.next;\n    }\n\n    if (current.next) {\n      current.next = current.next.next;\n    }\n  }\n\n  // Print the linked list\n  print() {\n    let result = '';\n    let current = this.head;\n\n    while (current) {\n      result += current.data + (current.next ? ' -> ' : '');\n      current = current.next;\n    }\n\n    console.log(result);\n  }\n}\n\n// Example usage:\n// const list = new LinkedList();\n// list.append(1);\n// list.append(2);\n// list.prepend(0);\n// list.print(); // Should output: 0 -> 1 -> 2\n// list.delete(1);\n// list.print(); // Should output: 0 -> 2`\n      }]\n    }\n  };\n  return moduleContent[moduleId] || null;\n};\nexport default getModuleContent;","map":{"version":3,"names":["getJavaScriptModuleContent","getPythonModuleContent","getModuleContent","moduleId","startsWith","moduleContent","id","title","content","type","body","description","source","notes","questions","text","options","correctAnswer","instructions","starterCode","solution"],"sources":["C:/Users/DELL/OneDrive/Documents/GitHub/AlgoHunt/src/data/moduleContentData.js"],"sourcesContent":["// This file contains sample module content data based on open source educational resources\n// Sources include:\n// - Open Data Structures (opendatastructures.org)\n// - Introduction to Algorithms, 3rd Edition (CLRS)\n// - Algorithms by Jeff Erickson\n// - MDN Web Docs (developer.mozilla.org)\n// - React Documentation (reactjs.org)\n// - Node.js Documentation (nodejs.org)\n// - Python.org and Real Python\n// - JavaScript.info and MDN Web Docs\n\nimport { getJavaScriptModuleContent } from './jsModuleContentData';\nimport { getPythonModuleContent } from './pythonModuleContentData';\n\nexport const getModuleContent = (moduleId) => {\n  // Check if this is a JavaScript module\n  if (moduleId.startsWith('js-mod-')) {\n    return getJavaScriptModuleContent(moduleId);\n  }\n\n  // Check if this is a Python module\n  if (moduleId.startsWith('py-mod-')) {\n    return getPythonModuleContent(moduleId);\n  }\n\n  // Otherwise, use the original module content\n  const moduleContent = {\n    // Arrays and Strings module content\n    \"m1\": {\n      id: \"m1\",\n      title: \"Arrays and Strings\",\n      content: [\n        {\n          type: \"text\",\n          title: \"Introduction to Arrays\",\n          body: `\n            <p>Arrays are one of the most fundamental data structures in computer science. An array is a collection of elements, each identified by an index or a key.</p>\n\n            <p>The simplest type of array is a <strong>linear array</strong> or <strong>one-dimensional array</strong>, which is a collection of data elements with the same data type, arranged using a single index.</p>\n\n            <p>Key characteristics of arrays:</p>\n            <ul>\n              <li><strong>Random Access</strong>: Elements can be accessed directly using their index</li>\n              <li><strong>Fixed Size</strong>: In many languages, arrays have a fixed size that is defined when the array is created</li>\n              <li><strong>Homogeneous Elements</strong>: All elements in the array have the same data type</li>\n              <li><strong>Contiguous Memory</strong>: Array elements are stored in adjacent memory locations</li>\n            </ul>\n\n            <p>The time complexity of common array operations:</p>\n            <ul>\n              <li>Access: O(1)</li>\n              <li>Search: O(n)</li>\n              <li>Insertion: O(n)</li>\n              <li>Deletion: O(n)</li>\n            </ul>\n\n            <p>Arrays are implemented differently in various programming languages. In low-level languages like C, arrays are fixed-size blocks of contiguous memory. In higher-level languages like JavaScript or Python, arrays are more flexible and can grow or shrink dynamically.</p>\n          `\n        },\n        {\n          type: \"text\",\n          title: \"Array Memory Layout\",\n          body: `\n            <p>Understanding how arrays are stored in memory is crucial for optimizing performance and understanding the limitations of arrays.</p>\n\n            <p>In most programming languages, arrays are stored in contiguous blocks of memory. This means that all elements of the array are stored next to each other in memory.</p>\n\n            <p>For example, if we have an array of integers where each integer takes 4 bytes of memory, and the array starts at memory address 1000, then:</p>\n            <ul>\n              <li>The first element (index 0) will be at address 1000</li>\n              <li>The second element (index 1) will be at address 1004</li>\n              <li>The third element (index 2) will be at address 1008</li>\n              <li>And so on...</li>\n            </ul>\n\n            <p>This contiguous memory layout is what allows arrays to provide O(1) access time. The memory address of any element can be calculated using the formula:</p>\n\n            <p><code>address = base_address + (index * element_size)</code></p>\n\n            <p>Where <code>base_address</code> is the memory address of the first element, <code>index</code> is the position of the element we want to access, and <code>element_size</code> is the size of each element in bytes.</p>\n\n            <p>This formula works because the elements are stored contiguously in memory, so we can simply calculate the offset from the base address.</p>\n          `\n        },\n        {\n          type: \"video\",\n          title: \"Array Data Structure Visualization\",\n          description: \"This video provides a visual explanation of how arrays work in memory and demonstrates common array operations.\",\n          source: \"CS Dojo\",\n          notes: \"Pay special attention to the visualization of array insertion and deletion operations, as they require shifting elements which leads to O(n) time complexity.\"\n        },\n        {\n          type: \"text\",\n          title: \"Dynamic Arrays\",\n          body: `\n            <p>While traditional arrays have a fixed size, many modern programming languages provide dynamic arrays that can grow or shrink as needed. Examples include ArrayList in Java, vector in C++, and the built-in arrays in JavaScript and Python.</p>\n\n            <p>Dynamic arrays overcome the limitation of fixed-size arrays by automatically resizing when they run out of space. When a dynamic array needs to grow, it typically:</p>\n\n            <ol>\n              <li>Allocates a new, larger array (usually twice the size of the original)</li>\n              <li>Copies all elements from the original array to the new array</li>\n              <li>Deallocates the original array</li>\n            </ol>\n\n            <p>This resizing operation is expensive (O(n) time complexity), but it happens infrequently enough that the amortized cost of adding an element to a dynamic array is still O(1).</p>\n\n            <p>The concept of <strong>amortized analysis</strong> is important here. While a single resize operation is expensive, it happens rarely enough that when we average the cost over many operations, the cost per operation is still constant.</p>\n\n            <p>Dynamic arrays provide a good balance between the flexibility of linked lists and the performance of fixed-size arrays.</p>\n          `\n        },\n        {\n          type: \"quiz\",\n          title: \"Array Concepts Quiz\",\n          description: \"Test your understanding of array concepts with this quiz.\",\n          questions: [\n            {\n              id: \"q1\",\n              text: \"What is the time complexity of accessing an element in an array by its index?\",\n              options: [\n                { id: \"a\", text: \"O(1)\" },\n                { id: \"b\", text: \"O(log n)\" },\n                { id: \"c\", text: \"O(n)\" },\n                { id: \"d\", text: \"O(n²)\" }\n              ],\n              correctAnswer: \"a\"\n            },\n            {\n              id: \"q2\",\n              text: \"What happens when a dynamic array needs to grow beyond its current capacity?\",\n              options: [\n                { id: \"a\", text: \"It returns an error\" },\n                { id: \"b\", text: \"It creates a new, larger array and copies the elements\" },\n                { id: \"c\", text: \"It automatically extends the existing memory block\" },\n                { id: \"d\", text: \"It converts to a linked list\" }\n              ],\n              correctAnswer: \"b\"\n            },\n            {\n              id: \"q3\",\n              text: \"What is the time complexity of inserting an element at the beginning of an array?\",\n              options: [\n                { id: \"a\", text: \"O(1)\" },\n                { id: \"b\", text: \"O(log n)\" },\n                { id: \"c\", text: \"O(n)\" },\n                { id: \"d\", text: \"O(n²)\" }\n              ],\n              correctAnswer: \"c\"\n            }\n          ]\n        },\n        {\n          type: \"exercise\",\n          title: \"Array Manipulation Exercise\",\n          description: \"Implement a function to reverse an array in-place without using any built-in reverse functions.\",\n          instructions: [\n            \"Create a function called 'reverseArray' that takes an array as input\",\n            \"The function should reverse the array in-place (without creating a new array)\",\n            \"Do not use any built-in reverse functions\",\n            \"Return the reversed array\"\n          ],\n          starterCode: `function reverseArray(arr) {\n  // Your code here\n\n  return arr;\n}\n\n// Example usage:\n// const arr = [1, 2, 3, 4, 5];\n// console.log(reverseArray(arr)); // Should output: [5, 4, 3, 2, 1]`,\n          solution: `function reverseArray(arr) {\n  let left = 0;\n  let right = arr.length - 1;\n\n  while (left < right) {\n    // Swap elements at left and right indices\n    const temp = arr[left];\n    arr[left] = arr[right];\n    arr[right] = temp;\n\n    // Move indices towards the center\n    left++;\n    right--;\n  }\n\n  return arr;\n}\n\n// Example usage:\n// const arr = [1, 2, 3, 4, 5];\n// console.log(reverseArray(arr)); // Should output: [5, 4, 3, 2, 1]`\n        }\n      ]\n    },\n\n    // Linked Lists module content\n    \"m2\": {\n      id: \"m2\",\n      title: \"Linked Lists\",\n      content: [\n        {\n          type: \"text\",\n          title: \"Introduction to Linked Lists\",\n          body: `\n            <p>A linked list is a linear data structure where elements are not stored in contiguous memory locations. Instead, each element (node) contains a reference (link) to the next node in the sequence.</p>\n\n            <p>Unlike arrays, linked lists do not provide random access to elements. To access a specific element, you must traverse the list from the beginning (head) until you reach the desired element.</p>\n\n            <p>The basic structure of a linked list node typically includes:</p>\n            <ul>\n              <li>Data: The value stored in the node</li>\n              <li>Next: A reference to the next node in the sequence</li>\n            </ul>\n\n            <p>Linked lists offer several advantages over arrays:</p>\n            <ul>\n              <li>Dynamic size: Linked lists can grow or shrink during execution</li>\n              <li>Efficient insertions and deletions: Adding or removing elements doesn't require shifting other elements</li>\n              <li>Flexible memory allocation: Nodes can be stored anywhere in memory</li>\n            </ul>\n\n            <p>However, linked lists also have some disadvantages:</p>\n            <ul>\n              <li>No random access: To access an element, you must traverse from the beginning</li>\n              <li>Extra memory: Each node requires additional memory for the reference</li>\n              <li>Cache performance: Nodes may be scattered in memory, reducing cache efficiency</li>\n            </ul>\n          `\n        },\n        {\n          type: \"text\",\n          title: \"Types of Linked Lists\",\n          body: `\n            <p>There are several types of linked lists, each with its own characteristics and use cases:</p>\n\n            <h4>Singly Linked List</h4>\n            <p>In a singly linked list, each node contains a reference to the next node in the sequence. Traversal can only be done in one direction, from the head to the tail.</p>\n\n            <pre>\nHead → [Data|Next] → [Data|Next] → [Data|Next] → null\n            </pre>\n\n            <h4>Doubly Linked List</h4>\n            <p>In a doubly linked list, each node contains references to both the next and previous nodes. This allows traversal in both directions but requires more memory per node.</p>\n\n            <pre>\nnull ← [Prev|Data|Next] ↔ [Prev|Data|Next] ↔ [Prev|Data|Next] → null\n       ↑\n      Head\n            </pre>\n\n            <h4>Circular Linked List</h4>\n            <p>In a circular linked list, the last node points back to the first node, creating a circle. This can be implemented with either singly or doubly linked lists.</p>\n\n            <pre>\n       ┌────────────────────────┐\n       ↓                        |\nHead → [Data|Next] → [Data|Next] → [Data|Next]\n            </pre>\n\n            <p>Each type of linked list has its own advantages and is suitable for different scenarios.</p>\n          `\n        },\n        {\n          type: \"video\",\n          title: \"Linked List Implementation\",\n          description: \"This video demonstrates how to implement a singly linked list from scratch, including common operations like insertion, deletion, and traversal.\",\n          source: \"freeCodeCamp.org\",\n          notes: \"Focus on understanding the pointer manipulation required for operations like insertion and deletion, as these are the key advantages of linked lists.\"\n        },\n        {\n          type: \"quiz\",\n          title: \"Linked List Concepts Quiz\",\n          description: \"Test your understanding of linked list concepts with this quiz.\",\n          questions: [\n            {\n              id: \"q1\",\n              text: \"What is the time complexity of accessing the nth element in a singly linked list?\",\n              options: [\n                { id: \"a\", text: \"O(1)\" },\n                { id: \"b\", text: \"O(log n)\" },\n                { id: \"c\", text: \"O(n)\" },\n                { id: \"d\", text: \"O(n²)\" }\n              ],\n              correctAnswer: \"c\"\n            },\n            {\n              id: \"q2\",\n              text: \"Which type of linked list allows traversal in both directions?\",\n              options: [\n                { id: \"a\", text: \"Singly linked list\" },\n                { id: \"b\", text: \"Doubly linked list\" },\n                { id: \"c\", text: \"Circular linked list\" },\n                { id: \"d\", text: \"Skip list\" }\n              ],\n              correctAnswer: \"b\"\n            },\n            {\n              id: \"q3\",\n              text: \"What is the time complexity of inserting a node at the beginning of a singly linked list?\",\n              options: [\n                { id: \"a\", text: \"O(1)\" },\n                { id: \"b\", text: \"O(log n)\" },\n                { id: \"c\", text: \"O(n)\" },\n                { id: \"d\", text: \"O(n²)\" }\n              ],\n              correctAnswer: \"a\"\n            }\n          ]\n        },\n        {\n          type: \"exercise\",\n          title: \"Linked List Implementation Exercise\",\n          description: \"Implement a singly linked list with basic operations.\",\n          instructions: [\n            \"Create a Node class with properties for the data and next pointer\",\n            \"Create a LinkedList class with a head property\",\n            \"Implement methods for append, prepend, delete, and print\",\n            \"Test your implementation with the provided example\"\n          ],\n          starterCode: `class Node {\n  // Your code here\n}\n\nclass LinkedList {\n  constructor() {\n    this.head = null;\n  }\n\n  // Add a node to the end of the list\n  append(data) {\n    // Your code here\n  }\n\n  // Add a node to the beginning of the list\n  prepend(data) {\n    // Your code here\n  }\n\n  // Delete a node with the given data\n  delete(data) {\n    // Your code here\n  }\n\n  // Print the linked list\n  print() {\n    // Your code here\n  }\n}\n\n// Example usage:\n// const list = new LinkedList();\n// list.append(1);\n// list.append(2);\n// list.prepend(0);\n// list.print(); // Should output: 0 -> 1 -> 2\n// list.delete(1);\n// list.print(); // Should output: 0 -> 2`,\n          solution: `class Node {\n  constructor(data) {\n    this.data = data;\n    this.next = null;\n  }\n}\n\nclass LinkedList {\n  constructor() {\n    this.head = null;\n  }\n\n  // Add a node to the end of the list\n  append(data) {\n    const newNode = new Node(data);\n\n    if (!this.head) {\n      this.head = newNode;\n      return;\n    }\n\n    let current = this.head;\n    while (current.next) {\n      current = current.next;\n    }\n\n    current.next = newNode;\n  }\n\n  // Add a node to the beginning of the list\n  prepend(data) {\n    const newNode = new Node(data);\n    newNode.next = this.head;\n    this.head = newNode;\n  }\n\n  // Delete a node with the given data\n  delete(data) {\n    if (!this.head) return;\n\n    if (this.head.data === data) {\n      this.head = this.head.next;\n      return;\n    }\n\n    let current = this.head;\n    while (current.next && current.next.data !== data) {\n      current = current.next;\n    }\n\n    if (current.next) {\n      current.next = current.next.next;\n    }\n  }\n\n  // Print the linked list\n  print() {\n    let result = '';\n    let current = this.head;\n\n    while (current) {\n      result += current.data + (current.next ? ' -> ' : '');\n      current = current.next;\n    }\n\n    console.log(result);\n  }\n}\n\n// Example usage:\n// const list = new LinkedList();\n// list.append(1);\n// list.append(2);\n// list.prepend(0);\n// list.print(); // Should output: 0 -> 1 -> 2\n// list.delete(1);\n// list.print(); // Should output: 0 -> 2`\n        }\n      ]\n    }\n  };\n\n  return moduleContent[moduleId] || null;\n};\n\nexport default getModuleContent;\n"],"mappings":"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,EAAE;UAAqB,CAAC,EACvC;YAAET,EAAE,EAAE,GAAG;YAAES,IAAI,EAAE;UAAqB,CAAC,EACvC;YAAET,EAAE,EAAE,GAAG;YAAES,IAAI,EAAE;UAAuB,CAAC,EACzC;YAAET,EAAE,EAAE,GAAG;YAAES,IAAI,EAAE;UAAY,CAAC,CAC/B;UACDE,aAAa,EAAE;QACjB,CAAC,EACD;UACEX,EAAE,EAAE,IAAI;UACRS,IAAI,EAAE,2FAA2F;UACjGC,OAAO,EAAE,CACP;YAAEV,EAAE,EAAE,GAAG;YAAES,IAAI,EAAE;UAAO,CAAC,EACzB;YAAET,EAAE,EAAE,GAAG;YAAES,IAAI,EAAE;UAAW,CAAC,EAC7B;YAAET,EAAE,EAAE,GAAG;YAAES,IAAI,EAAE;UAAO,CAAC,EACzB;YAAET,EAAE,EAAE,GAAG;YAAES,IAAI,EAAE;UAAQ,CAAC,CAC3B;UACDE,aAAa,EAAE;QACjB,CAAC;MAEL,CAAC,EACD;QACER,IAAI,EAAE,UAAU;QAChBF,KAAK,EAAE,qCAAqC;QAC5CI,WAAW,EAAE,uDAAuD;QACpEO,YAAY,EAAE,CACZ,mEAAmE,EACnE,gDAAgD,EAChD,0DAA0D,EAC1D,oDAAoD,CACrD;QACDC,WAAW,EAAE;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;QAChCC,QAAQ,EAAE;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;MACQ,CAAC;IAEL;EACF,CAAC;EAED,OAAOf,aAAa,CAACF,QAAQ,CAAC,IAAI,IAAI;AACxC,CAAC;AAED,eAAeD,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}