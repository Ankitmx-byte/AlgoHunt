{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\DELL\\\\OneDrive\\\\Documents\\\\GitHub\\\\AlgoHunt\\\\src\\\\components\\\\ParticleCanvas3D.jsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef } from 'react';\nimport './ParticleCanvas3D.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ParticleCanvas3D = ({\n  particleCount = 100,\n  particleColor = '#6366f1',\n  backgroundColor = 'transparent',\n  depth = 300,\n  particleSize = 2,\n  speed = 0.5,\n  interactive = true,\n  connectParticles = true,\n  maxConnections = 3,\n  connectionDistance = 150\n}) => {\n  _s();\n  const canvasRef = useRef(null);\n  const particlesRef = useRef([]);\n  const mouseRef = useRef({\n    x: 0,\n    y: 0,\n    isActive: false\n  });\n  const animationRef = useRef(null);\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    let width, height;\n\n    // Set canvas dimensions\n    const setDimensions = () => {\n      width = canvas.width = window.innerWidth;\n      height = canvas.height = window.innerHeight;\n    };\n\n    // Initialize particles\n    const initParticles = () => {\n      particlesRef.current = [];\n      for (let i = 0; i < particleCount; i++) {\n        particlesRef.current.push({\n          x: Math.random() * width,\n          y: Math.random() * height,\n          z: Math.random() * depth,\n          vx: (Math.random() - 0.5) * speed,\n          vy: (Math.random() - 0.5) * speed,\n          vz: (Math.random() - 0.5) * speed,\n          connections: 0\n        });\n      }\n    };\n\n    // Calculate particle projection\n    const project = (x, y, z) => {\n      const perspective = depth / (depth + z);\n      return {\n        x: x * perspective + width / 2,\n        y: y * perspective + height / 2,\n        scale: perspective\n      };\n    };\n\n    // Draw a single particle\n    const drawParticle = particle => {\n      const projection = project(particle.x - width / 2, particle.y - height / 2, particle.z);\n      const size = particleSize * projection.scale;\n      const opacity = projection.scale * 0.8;\n      ctx.beginPath();\n      ctx.arc(projection.x, projection.y, size, 0, Math.PI * 2);\n      ctx.fillStyle = particleColor.replace(')', `, ${opacity})`).replace('rgb', 'rgba');\n      ctx.fill();\n      return projection;\n    };\n\n    // Connect particles with lines\n    const connectParticle = (particle, projection, index) => {\n      if (!connectParticles || particle.connections >= maxConnections) return;\n      for (let i = index + 1; i < particlesRef.current.length; i++) {\n        const otherParticle = particlesRef.current[i];\n        if (otherParticle.connections >= maxConnections) continue;\n        const otherProjection = project(otherParticle.x - width / 2, otherParticle.y - height / 2, otherParticle.z);\n        const dx = projection.x - otherProjection.x;\n        const dy = projection.y - otherProjection.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        if (distance < connectionDistance) {\n          const opacity = (1 - distance / connectionDistance) * 0.5 * projection.scale * otherProjection.scale;\n          ctx.beginPath();\n          ctx.moveTo(projection.x, projection.y);\n          ctx.lineTo(otherProjection.x, otherProjection.y);\n          ctx.strokeStyle = particleColor.replace(')', `, ${opacity})`).replace('rgb', 'rgba');\n          ctx.lineWidth = 1 * Math.min(projection.scale, otherProjection.scale);\n          ctx.stroke();\n          particle.connections++;\n          otherParticle.connections++;\n        }\n      }\n    };\n\n    // Update particle positions\n    const updateParticles = () => {\n      particlesRef.current.forEach(particle => {\n        particle.connections = 0;\n\n        // Update position\n        particle.x += particle.vx;\n        particle.y += particle.vy;\n        particle.z += particle.vz;\n\n        // Boundary checks with wrapping\n        if (particle.x < 0) particle.x = width;else if (particle.x > width) particle.x = 0;\n        if (particle.y < 0) particle.y = height;else if (particle.y > height) particle.y = 0;\n        if (particle.z < 0) particle.z = depth;else if (particle.z > depth) particle.z = 0;\n\n        // Mouse interaction\n        if (interactive && mouseRef.current.isActive) {\n          const dx = particle.x - mouseRef.current.x;\n          const dy = particle.y - mouseRef.current.y;\n          const distance = Math.sqrt(dx * dx + dy * dy);\n          if (distance < 150) {\n            const force = 0.1 * (1 - distance / 150);\n            particle.vx += dx / distance * force;\n            particle.vy += dy / distance * force;\n          }\n        }\n      });\n    };\n\n    // Main animation loop\n    const animate = () => {\n      ctx.fillStyle = backgroundColor;\n      ctx.fillRect(0, 0, width, height);\n      updateParticles();\n\n      // Sort particles by z-depth for proper rendering\n      const sortedParticles = [...particlesRef.current].sort((a, b) => b.z - a.z);\n\n      // Draw particles and connections\n      sortedParticles.forEach((particle, index) => {\n        const projection = drawParticle(particle);\n        connectParticle(particle, projection, index);\n      });\n      animationRef.current = requestAnimationFrame(animate);\n    };\n\n    // Mouse event handlers\n    const handleMouseMove = e => {\n      mouseRef.current.x = e.clientX;\n      mouseRef.current.y = e.clientY;\n      mouseRef.current.isActive = true;\n    };\n    const handleMouseLeave = () => {\n      mouseRef.current.isActive = false;\n    };\n\n    // Initialize\n    setDimensions();\n    initParticles();\n    animate();\n\n    // Event listeners\n    window.addEventListener('resize', () => {\n      setDimensions();\n      initParticles();\n    });\n    if (interactive) {\n      canvas.addEventListener('mousemove', handleMouseMove);\n      canvas.addEventListener('mouseleave', handleMouseLeave);\n    }\n\n    // Cleanup\n    return () => {\n      cancelAnimationFrame(animationRef.current);\n      window.removeEventListener('resize', setDimensions);\n      if (interactive) {\n        canvas.removeEventListener('mousemove', handleMouseMove);\n        canvas.removeEventListener('mouseleave', handleMouseLeave);\n      }\n    };\n  }, [particleCount, particleColor, backgroundColor, depth, particleSize, speed, interactive, connectParticles, maxConnections, connectionDistance]);\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef,\n    className: \"particle-canvas-3d\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 205,\n    columnNumber: 5\n  }, this);\n};\n_s(ParticleCanvas3D, \"bzJtNdMv66PkEaLhW7Fca3SSV2A=\");\n_c = ParticleCanvas3D;\nexport default ParticleCanvas3D;\nvar _c;\n$RefreshReg$(_c, \"ParticleCanvas3D\");","map":{"version":3,"names":["React","useEffect","useRef","jsxDEV","_jsxDEV","ParticleCanvas3D","particleCount","particleColor","backgroundColor","depth","particleSize","speed","interactive","connectParticles","maxConnections","connectionDistance","_s","canvasRef","particlesRef","mouseRef","x","y","isActive","animationRef","canvas","current","ctx","getContext","width","height","setDimensions","window","innerWidth","innerHeight","initParticles","i","push","Math","random","z","vx","vy","vz","connections","project","perspective","scale","drawParticle","particle","projection","size","opacity","beginPath","arc","PI","fillStyle","replace","fill","connectParticle","index","length","otherParticle","otherProjection","dx","dy","distance","sqrt","moveTo","lineTo","strokeStyle","lineWidth","min","stroke","updateParticles","forEach","force","animate","fillRect","sortedParticles","sort","a","b","requestAnimationFrame","handleMouseMove","e","clientX","clientY","handleMouseLeave","addEventListener","cancelAnimationFrame","removeEventListener","ref","className","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/DELL/OneDrive/Documents/GitHub/AlgoHunt/src/components/ParticleCanvas3D.jsx"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\nimport './ParticleCanvas3D.css';\n\nconst ParticleCanvas3D = ({ \n  particleCount = 100, \n  particleColor = '#6366f1', \n  backgroundColor = 'transparent',\n  depth = 300,\n  particleSize = 2,\n  speed = 0.5,\n  interactive = true,\n  connectParticles = true,\n  maxConnections = 3,\n  connectionDistance = 150\n}) => {\n  const canvasRef = useRef(null);\n  const particlesRef = useRef([]);\n  const mouseRef = useRef({ x: 0, y: 0, isActive: false });\n  const animationRef = useRef(null);\n  \n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    let width, height;\n    \n    // Set canvas dimensions\n    const setDimensions = () => {\n      width = canvas.width = window.innerWidth;\n      height = canvas.height = window.innerHeight;\n    };\n    \n    // Initialize particles\n    const initParticles = () => {\n      particlesRef.current = [];\n      for (let i = 0; i < particleCount; i++) {\n        particlesRef.current.push({\n          x: Math.random() * width,\n          y: Math.random() * height,\n          z: Math.random() * depth,\n          vx: (Math.random() - 0.5) * speed,\n          vy: (Math.random() - 0.5) * speed,\n          vz: (Math.random() - 0.5) * speed,\n          connections: 0\n        });\n      }\n    };\n    \n    // Calculate particle projection\n    const project = (x, y, z) => {\n      const perspective = depth / (depth + z);\n      return {\n        x: x * perspective + width / 2,\n        y: y * perspective + height / 2,\n        scale: perspective\n      };\n    };\n    \n    // Draw a single particle\n    const drawParticle = (particle) => {\n      const projection = project(\n        particle.x - width / 2,\n        particle.y - height / 2,\n        particle.z\n      );\n      \n      const size = particleSize * projection.scale;\n      const opacity = projection.scale * 0.8;\n      \n      ctx.beginPath();\n      ctx.arc(projection.x, projection.y, size, 0, Math.PI * 2);\n      ctx.fillStyle = particleColor.replace(')', `, ${opacity})`).replace('rgb', 'rgba');\n      ctx.fill();\n      \n      return projection;\n    };\n    \n    // Connect particles with lines\n    const connectParticle = (particle, projection, index) => {\n      if (!connectParticles || particle.connections >= maxConnections) return;\n      \n      for (let i = index + 1; i < particlesRef.current.length; i++) {\n        const otherParticle = particlesRef.current[i];\n        if (otherParticle.connections >= maxConnections) continue;\n        \n        const otherProjection = project(\n          otherParticle.x - width / 2,\n          otherParticle.y - height / 2,\n          otherParticle.z\n        );\n        \n        const dx = projection.x - otherProjection.x;\n        const dy = projection.y - otherProjection.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        \n        if (distance < connectionDistance) {\n          const opacity = (1 - distance / connectionDistance) * 0.5 * projection.scale * otherProjection.scale;\n          \n          ctx.beginPath();\n          ctx.moveTo(projection.x, projection.y);\n          ctx.lineTo(otherProjection.x, otherProjection.y);\n          ctx.strokeStyle = particleColor.replace(')', `, ${opacity})`).replace('rgb', 'rgba');\n          ctx.lineWidth = 1 * Math.min(projection.scale, otherProjection.scale);\n          ctx.stroke();\n          \n          particle.connections++;\n          otherParticle.connections++;\n        }\n      }\n    };\n    \n    // Update particle positions\n    const updateParticles = () => {\n      particlesRef.current.forEach(particle => {\n        particle.connections = 0;\n        \n        // Update position\n        particle.x += particle.vx;\n        particle.y += particle.vy;\n        particle.z += particle.vz;\n        \n        // Boundary checks with wrapping\n        if (particle.x < 0) particle.x = width;\n        else if (particle.x > width) particle.x = 0;\n        \n        if (particle.y < 0) particle.y = height;\n        else if (particle.y > height) particle.y = 0;\n        \n        if (particle.z < 0) particle.z = depth;\n        else if (particle.z > depth) particle.z = 0;\n        \n        // Mouse interaction\n        if (interactive && mouseRef.current.isActive) {\n          const dx = particle.x - mouseRef.current.x;\n          const dy = particle.y - mouseRef.current.y;\n          const distance = Math.sqrt(dx * dx + dy * dy);\n          \n          if (distance < 150) {\n            const force = 0.1 * (1 - distance / 150);\n            particle.vx += (dx / distance) * force;\n            particle.vy += (dy / distance) * force;\n          }\n        }\n      });\n    };\n    \n    // Main animation loop\n    const animate = () => {\n      ctx.fillStyle = backgroundColor;\n      ctx.fillRect(0, 0, width, height);\n      \n      updateParticles();\n      \n      // Sort particles by z-depth for proper rendering\n      const sortedParticles = [...particlesRef.current].sort((a, b) => b.z - a.z);\n      \n      // Draw particles and connections\n      sortedParticles.forEach((particle, index) => {\n        const projection = drawParticle(particle);\n        connectParticle(particle, projection, index);\n      });\n      \n      animationRef.current = requestAnimationFrame(animate);\n    };\n    \n    // Mouse event handlers\n    const handleMouseMove = (e) => {\n      mouseRef.current.x = e.clientX;\n      mouseRef.current.y = e.clientY;\n      mouseRef.current.isActive = true;\n    };\n    \n    const handleMouseLeave = () => {\n      mouseRef.current.isActive = false;\n    };\n    \n    // Initialize\n    setDimensions();\n    initParticles();\n    animate();\n    \n    // Event listeners\n    window.addEventListener('resize', () => {\n      setDimensions();\n      initParticles();\n    });\n    \n    if (interactive) {\n      canvas.addEventListener('mousemove', handleMouseMove);\n      canvas.addEventListener('mouseleave', handleMouseLeave);\n    }\n    \n    // Cleanup\n    return () => {\n      cancelAnimationFrame(animationRef.current);\n      window.removeEventListener('resize', setDimensions);\n      \n      if (interactive) {\n        canvas.removeEventListener('mousemove', handleMouseMove);\n        canvas.removeEventListener('mouseleave', handleMouseLeave);\n      }\n    };\n  }, [particleCount, particleColor, backgroundColor, depth, particleSize, speed, interactive, connectParticles, maxConnections, connectionDistance]);\n  \n  return (\n    <canvas ref={canvasRef} className=\"particle-canvas-3d\" />\n  );\n};\n\nexport default ParticleCanvas3D;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}